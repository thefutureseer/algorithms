
~Runtime complexity~ 


NOTE on Big O:
Big O() notation folder breaks down a more concrete way to compare algorithms. The letter o is used because
the rate of growth of a function is also called "ORDER OF THE FUNCTION".

Goal of this Big(O) folder: The ability to identify runtime complexity.

   "Describe the performance of an algorithm" -H.T.

THE BIG QUESTION:
*) How much more PROCESSING POWER/TIME is required to run your algorithm if we
DOUBLE THE INPUTS.


Note: The first algorithm may not be the most efficient but the fastest to code, assuming it will be replaced
with a more efficient one in a later version. I.E. Common in agile divelopment, esp Test driven development.

COMMON RUNTIMES used to identify many different algorithms:

1) n = input size
2) Constants are never used. Constants are always canceled out.

CONSTANT runtime/"Order 1"/ = 1 as Seen as: O(1).
      No matter how many elements we are working with the algorithm/operation/whatever
      will always take the same amount of time. Its bound by a value not by the inputs.
      You will see this on algorithms that return an element in an already known position of an
      array regardless of kind or length.
 I.E. 
   1) The function GETFIRSTVALUE() because it always returns the first value.
   2) Variable doesnt do anything exept hold an integer = O(1).
        Also the adding of the integer in that variable to another integer = O(1).
   3) Including a function returning that variable value = O(1) as long 
        as the number can fit into a single integer variable.

LOGARITHMIC runtime/ = as seen as: O(log(n))
  I.E.
    1) DOUBLING the number of elements you are iterating over does NOT double the amount of work.
    2) Time goes up linearly while "n" goes up exponentialy: If the iteration of 10 elements takes 1 second
         100 elements takes 2 seconds, 1000 elements takes 3 seconds. 
    3) Usually the result of a search in an array (which is after the array is sorted).
    4) The runtime grows in proportion of the logarithm of the input size. 
    5) More complex than constants but not as complex as polynomials.

  NOTE: Always assume search operations are log(n)
  Story to remember it: In jr. high school everybody was forced to take a choir class because we had a famous
                        teacher who the school was able to workout a deal with. All of us students were excited 
                        to get our own number and knew exactly where to stand for the big show. Every student 
                        could scream out their number if ask. It doesn't matter how many students 
                        would be in attendence, it never takes any extra work for the teacher to say your name
                        over the mic and get your number as a response.

LOGARITHMIC runtime/ O(n log(n)) 
  I.E.
    comming soon

LINEAR runtime/ = as seen as: O(n) 
  I.E. 
    1) Looping through an entire collection will probably be O(n)
    2) iterating through half of the same collection is still O(n)
    3) LINEAR = Adding one element to the input set will add one unit of more time to complete the algorithm so
        Doubling the number of inputs affects the growth of the algorithm proportionally. 
    4) "Method to Reverse string" O(n)
   *5) Worst case time complexity for quick sort is O(nÂ²)

LINEAR runtime/ = as seen as: O(n + m)
  1) Iterating through two seperate collections with 2 loops doing the same thing
       Reverse two different strings with one function call
  2) LINEAR =  Adding one element will add one unit of more time to complete the algorithm So DOUBLING the 
      number of inputs affects the growth of the algorithm proportionally. 





Exponential runtime/
Image: "How to save a million dollars", highlighting an "exponential" growth pattern.
As a child growing up in Oakland, California a teacher of mine said something that stuck with me and motivated
me. He said, "Do you want to know how to save a million dollars? If you want to save money, just try saving 
or 30 days straight. Save one penny on the first day and the second day save double so now you have 3 cents, 
right? Then the 3 day you double it again and everyday after that you do the same thing, you take the amount
you have and double it. You do that for 30 days straight and you will have over one million dollars in your
savings!". 

