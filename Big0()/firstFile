
Runtime compexity

NOTE on Big O:
Big O() notation folder breaks down a more concrete way to compare algorithms. The letter o is used because
the rate of growth of a function is also called "ORDER OF THE FUNCTION".

Goal of this Big(O) folder: The ability to identify runtime complexity.

   "Describe the performance of an algorithm" -H.T.

THE BIG QUESTION:
*) How much more PROCESSING POWER/TIME is required to run your algorithm if we
DOUBLE THE INPUTS.

BREIF STORY: "How to save a million dollars", highlighting an "exponential" growth pattern of Big O productions.
As a child growing up in Oakland, California a teacher of mine said something that stuck with me and motivated
me. He said, "Do you want to know how to save a million dollars? If you want to save money, just try saving 
or 30 days straight. Save one penny on the first day and the second day save double so now you have 3 cents, 
right? Then the 3 day you double it again and everyday after that you do the same thing, you take the amount
you have and double it. You do that for 30 days straight and you will have over one million dollars in your
savings!". 

Note: The first algorithm may not be the most efficient but the fastest to code, assuming it will be replaced
with a more efficient one in a later version. I.E. Common in agile divelopment, esp Test driven development.

COMMON RUNTIMES used to identify many different algorithms:

n = input size

constant time/"Order 1"/ = 1 or Seen as: big O(1).
      No matter how many elements we are working with the algorithm/operation/whatever
      will always take the same amount of time. Its bound by a value not by the inputs.
      You will see this on algorithms that return an element in an already known position of an
      array regardless of kind or length.
 I.E. 
   1) The function GETFIRSTVALUE() because it always returns the first value.
   2) Variable doesnt do anything exept hold an integer = O(1).
        Also the adding of the integer in that variable to another integer = O(1).
   3) Including a function returning that variable value = O(1) as long 
        as the number can fit into a single integer variable.

logarithmic time/ = log(n)
         "You have this if DOUBLING the number of elements you are iterating over does NOT 
         double the amount of work."
  I.E.
    1)


  NOTE: Always assume search operations are log(n)

